<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // const promise = new Promise((resolve, reject)=>{
        //     console.log('수행중....');
        //     setTimeout(()=>{
        //         reject(new Error('not found'))
        //     },2000)
        // })

        // promise.then(value=>console.log(value))
        // .catch(error=>console.log(error))
        // .finally(()=>{
        //     console.log('끝났어요');
        // })

        // // function fetchUser(){
        // //     return new Promise((resolve, reject)=>{
        // //         reject ('프로미스 성공');
        // //     })
        // // }
        // // const user = fetchUser();
        // // console.log(user);

        // //then은 값을 전달할 수도 있고, 또 다른 프로미스도 전달할 수 있음
        // const fetchNumber = new Promise((resolve, reject)=>{
        //     setTimeout(()=>resolve(1),1000)
        // })
        // fetchNumber.then(num => num * 2)
        // .then(num => num*3)
        // .then(num =>{
        //     return new Promise((resolve, reject)=>{
        //         setTimeout(()=>resolve(num-1),1000)
        //     })
        // }).then(num => console.log(num))

        // function getHen(){
        //     return new Promise((resolve, reject)=>{
        //         setTimeout(()=>resolve('암닭'),1000);
        //     })
        // }
        // function getEgg(){
        //     return new Promise((resolve, reject)=>{
        //         setTimeout(()=>reject(new Error('계란을 받아올 수 없음')),1000)
        //     })
        // }
        // function cook(egg){
        //     return new Promise((resolve, reject)=>{
        //         setTimeout(resolve(egg+'후라이'),1000)
        //     })
        // }

        // //getEgg에서 error가 발생 -> 해당 에러를 햄으로 다시 리턴. 그 햄이 egg에 들어가게 되고 그걸 콘솔에 출력하는 구문
        // getHen()
        // .then(getEgg)
        // .catch(error=>{
        //     return '햄';
        // }).then(cook).then(console.log)

        
        
        // //async를 함수안에 적으면 프로미스를 쓰지 않아도 함수안에 블럭이 프로미스로 적용
        // //await
        // //async가 붙은 함수 안에서만 사용할 수 있음
        // function delay(ms){
        //     return new Promise((resolve, reject)=>setTimeout(resolve,ms))
        // }
        // async function getApple(){
        //     await delay(2000);
        //     return '사과';
        // }
        // async function getBanana(){
        //     await delay(2000);
        //     return '바나나';
        // }
        // async function pickFruits(){
        //     const apple = await getApple();
        //     const banana = await getBanana();
        //     return `${apple}+${banana}`;
        // }
        // pickFruits().then(console.log);


        //함수 앞에 async가 붙으면 해당 함수는 함상 프로미스를 반환
        //프로미스가 아닌 것을 프로미스로 감싸서 반환
        //await : 프로미스가 처리될 때 까지 기다림
        //await은 async 키워드가 있는 함수 안에서만 사용 가능
        async function asyfu(){
            return '이거에요';
        }
        asyfu().then(console.log);
        async function asyfu2(){
            return Promise.resolve('이거에요2');
        }
        asyfu2().then(console.log);

        async function promiseF(){
            let promise = new Promise((resolve, reject)=>{
                setTimeout(()=>resolve('완료'),1000)
            });
            //promise에 바로 값이 담기지 않고 결과가 나올 때까지 기다렸다가 결과가 나와야 담김 
            let result = await promise;
        }

        //에러 핸들링
        // async function f(){
        //     await Promise.reject(new Error('에러발생'));
        // }
        // async function f(){
        //    throw new Error('에러발생')
        // }

        async function f(){
            try{
                let response = await fetch('유효하지않은 주소');
            }
            catch(e){
                console.log(e);
            }
        }
    </script>
</body>
</html>